{"version":3,"sources":["./spatial-navigation-polyfill.js"],"names":["undefined","window","navigate","ARROW_KEY_CODE","37","38","39","40","TAB_KEY_CODE","mapOfBoundRect","startingPoint","navnotargetPrevented","navbeforefocusPrevented","initiateSpatialNavigation","Element","prototype","spatialNavigationSearch","focusableAreas","getSpatialNavigationContainer","CSS","registerProperty","getComputedStyle","document","documentElement","getPropertyValue","name","u","s","l","addEventListener","e","currentKeyMode","parent","__spatialNavigation__","keyMode","eventTarget","activeElement","dir","keyCode","shiftKey","defaultPrevented","focusNavigableArrowKey","left","m","right","p","nodeName","startPosition","selectionStart","endPosition","selectionEnd","includes","getAttribute","up","value","length","down","handlingEditableElement","preventDefault","Map","x","clientX","y","clientY","body","searchOrigin","querySelector","findSearchOrigin","elementFromPosition","elementFromPoint","contains","isContainer","contentDocument","getCSSSpatNavAction","scrollingController","focusingController","mode","container","navigateChain","bestCandidate","isScrollContainer","element","rect","getBoundingClientRect","containerRect","top","bottom","isEntirelyVisible","scrollIntoView","createSpatNavEvents","focus","isScrollable","isScrollBoundary","moveScroll","parentElement","isHTMLScrollBoundary","spatNavCandidates","candidates","targetElement","filteredCandidates","this","targetElementInTarget","every","currentElm","getClosestElement","getDistanceFromPoint","getInnerDistance","selectBestCandidateFromEdge","getDistance","selectBestCandidate","originalContainer","eventTargetRect","isVisible","filter","candidate","rect1","rect2","isRightSide","isBelow","isOutside","distanceFunction","minDistance","Number","POSITIVE_INFINITY","minDistanceElement","i","distance","location","option","focusables","Array","call","getElementsByTagName","isFocusable","eventType","containerElement","currentElement","direction","data","g","triggeredEvent","CustomEvent","bubbles","cancelable","detail","dispatchEvent","readCssVar","varName","style","trim","parentContainer","frameElement","offset","scrollLeft","scrollTop","elementStyle","overflowX","overflowY","isOverflow","scrollWidth","clientWidth","scrollHeight","clientHeight","result","scrollX","scrollY","winScrollY","winScrollX","height","width","Math","abs","tabIndex","tagName","isAtagWithoutHref","isActuallyDisabled","ownerDocument","inert","isExpresslyInert","isVisibleStyleProperty","opacity","isBeingRendered","offsetX","parseInt","offsetWidth","offsetY","offsetHeight","isNaN","elementRect","middleElem","leftTopElem","leftBottomElem","rightTopElem","rightBottomElem","hitTest","thisVisibility","isAligned","point","points","getEntryAndExitPoints","P1","entryPoint","exitPoint","P2","sqrt","pow","baseEdge","candidateRect","orthogonalBias","alignBias","A","B","C","intersectionRect","intersection_rect","N","new_location","max","new_max_point","min","area","getIntersectionRect","D","v","k","get","boundingClientRect","toFixed","set","enableExperimentalAPIs","getInitialAPIs","Object","assign","canScroll","findTarget","findCandidate","bestNextTarget","isArray","T","bind","O","R","candidateElement","getExperimentalAPI","seal","I","h","_keymode"],"mappings":"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","sourcesContent":["/* Spatial Navigation Polyfill\n * \n * It follows W3C official specification\n * https://drafts.csswg.org/css-nav-1/\n *\n * Copyright (c) 2018-2019 LG Electronics Inc.\n * https://github.com/WICG/spatial-navigation/polyfill\n *\n * Licensed under the MIT license (MIT)\n */\n\n(function () {\n\n  // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.\n  if (window.navigate !== undefined) {\n    return;\n  }\n\n  const ARROW_KEY_CODE = {37: 'left', 38: 'up', 39: 'right', 40: 'down'};\n  const TAB_KEY_CODE = 9;\n  let mapOfBoundRect = null;\n  let startingPoint = null; // Indicates global variables for spatnav (starting position)\n\n  let navnotargetPrevented = false; // Indicates the navnotarget event is prevented or not\n  let navbeforefocusPrevented = false; // Indicates the navbeforefocus event is prevented or not\n\n  /**\n   * Initiate the spatial navigation features of the polyfill.\n   * This function defines which input methods trigger the spatial navigation behavior.\n   * @function initiateSpatialNavigation\n   */\n  function initiateSpatialNavigation() {\n    /*\n     * Bind the standards APIs to be exposed to the window object for authors\n     */\n    window.navigate = navigate;\n    window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;\n    window.Element.prototype.focusableAreas = focusableAreas;\n    window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;\n\n    /*\n     * CSS.registerProperty() from the Properties and Values API\n     * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function\n     */\n    if (window.CSS && CSS.registerProperty &&\n      window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') === '') {\n      CSS.registerProperty({\n        name: '--spatial-navigation-contain',\n        syntax: 'auto | contain',\n        inherits: false,\n        initialValue: 'auto'\n      });\n    }\n\n    /*\n     * CSS.registerProperty() from the Properties and Values API\n     * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function\n     */\n    if (window.CSS && CSS.registerProperty &&\n      window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === '') {\n      CSS.registerProperty({\n        name: '--spatial-navigation-action',\n        syntax: 'auto | focus | scroll',\n        inherits: false,\n        initialValue: 'auto'\n      });\n    }\n\n    /*\n     * keydown EventListener :\n     * If arrow key pressed, get the next focusing element and send it to focusing controller\n     */\n    window.addEventListener('keydown', e => {\n      const currentKeyMode = (parent && parent.__spatialNavigation__.keyMode) || window.__spatialNavigation__.keyMode;\n      const eventTarget = document.activeElement;\n      const dir = ARROW_KEY_CODE[e.keyCode];\n\n      if (e.keyCode === TAB_KEY_CODE)\n        startingPoint = null;\n\n      if (!currentKeyMode ||\n          (currentKeyMode === 'NONE') ||\n          ((currentKeyMode === 'SHIFTARROW') && !e.shiftKey) ||\n          ((currentKeyMode === 'ARROW') && e.shiftKey))\n        return;\n\n      if (!e.defaultPrevented) {\n        let focusNavigableArrowKey = {left: true, up: true, right: true, down: true};\n\n        // Edge case (text input, area) : Don't move focus, just navigate cursor in text area\n        if ((eventTarget.nodeName === 'INPUT') || eventTarget.nodeName === 'TEXTAREA')\n          focusNavigableArrowKey = handlingEditableElement(e);\n\n        if (focusNavigableArrowKey[dir]) {\n          e.preventDefault();\n          mapOfBoundRect = new Map();\n\n          navigate(dir);\n\n          mapOfBoundRect = null;\n          startingPoint = null;\n        }\n      }\n    });\n\n    /*\n     * mouseup EventListener :\n     * If the mouse click a point in the page, the point will be the starting point.\n     * NOTE: Let UA set the spatial navigation starting point based on click\n     */\n    document.addEventListener('mouseup', e => {\n      startingPoint = {x: e.clientX, y: e.clientY};\n    });\n\n    /*\n     * navbeforefocus EventListener :\n     * If the navbeforefocus event is triggered, then the navbeforefocusPrevented flag can be set\n     * for define the prevented default behavior for the event\n     */\n    document.body.addEventListener('navbeforefocus', e => {\n      navbeforefocusPrevented = e.defaultPrevented;\n    });\n\n    /*\n     * navnotarget EventListener :\n     * If the navnotarget event is triggered, then the navnotargetPrevented flag can be set\n     * for define the prevented default behavior for the event\n     */\n    document.body.addEventListener('navnotarget', e => {\n      navnotargetPrevented = e.defaultPrevented;\n    });\n  }\n\n  /**\n   * Enable the author to trigger spatial navigation programatically, as if the user had done so manually.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}\n   * @function navigate\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   */\n  function navigate(dir) {\n    // spatial navigation steps\n\n    // 1\n    const searchOrigin = findSearchOrigin();\n    let eventTarget = null;\n    let elementFromPosition = null;\n\n    // 2 Optional step, UA defined starting point\n    if (startingPoint) {\n      elementFromPosition = (document.elementFromPoint(startingPoint.x, startingPoint.y)).getSpatialNavigationContainer();\n    }\n\n    // 3\n    if (elementFromPosition && searchOrigin.contains(elementFromPosition)) {\n      eventTarget = elementFromPosition;\n    } else {\n      eventTarget = searchOrigin;\n    }\n\n    // 4\n    if (eventTarget === document || eventTarget === document.documentElement) {\n      eventTarget = document.body || document.documentElement;\n    }\n\n    // 5\n    // At this point, spatialNavigationSearch can be applied.\n    // If startingPoint is either a scroll container or the document,\n    // find the best candidate within startingPoint\n    if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n      if (eventTarget.nodeName === 'IFRAME')\n        eventTarget = eventTarget.contentDocument.body;\n\n      // 5-2\n      if (getCSSSpatNavAction(eventTarget) === 'scroll') {\n        if (scrollingController(eventTarget, dir)) return;\n      } else if (getCSSSpatNavAction(eventTarget) === 'focus') {\n        if (focusingController(eventTarget.spatialNavigationSearch(dir, eventTarget.focusableAreas({mode: 'all'})), dir)) return;\n      } else if (getCSSSpatNavAction(eventTarget) === 'auto') {\n        if (focusingController(eventTarget.spatialNavigationSearch(dir), dir)) return;\n        if (scrollingController(eventTarget, dir)) return;\n      }\n    }\n\n    // 6\n    // Let container be the nearest ancestor of eventTarget\n    let container = eventTarget.getSpatialNavigationContainer();\n    \n    if (getCSSSpatNavAction(eventTarget) === 'focus') {\n      navigateChain(eventTarget, container, 'all', dir);\n    }\n    else if (getCSSSpatNavAction(container) === 'auto') {\n      navigateChain(eventTarget, container, 'visible', dir);\n\n      // Behavior before getting out from the current spatnav container\n      if (scrollingController(container, dir)) return;\n    }    \n  }\n\n  /**\n   * Move the focus to the best candidate or do nothing.\n   * @function focusingController\n   * @param bestCandidate {Node} - The best candidate of the spatial navigation\n   * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function focusingController(bestCandidate, dir) {\n    // 10 & 11\n    // When bestCandidate is found\n    if (bestCandidate) {\n      const container = bestCandidate.getSpatialNavigationContainer();\n\n      // Scrolling container or document when the next focusing element isn't entirely visible\n      if (isScrollContainer(container) && !isEntirelyVisible(bestCandidate))\n        bestCandidate.scrollIntoView();\n\n      // When bestCandidate is a focusable element and not a container : move focus\n      /*\n       * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.\n       */\n      createSpatNavEvents('beforefocus', bestCandidate, null, dir);\n      if (!navbeforefocusPrevented) {\n        bestCandidate.focus();\n        return true;\n      }\n    }\n\n    // When bestCandidate is not found within the scrollport of a container: Nothing\n    return false;\n  }\n\n  /**\n   * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.\n   * @function scrollingController\n   * @param container {Node} - The spatial navigation container which can scroll\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function scrollingController(container, dir) {\n\n    // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document\n    if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {\n      moveScroll(container, dir);\n      return true;\n    }\n\n    // If the spatnav container is document and it can be scrolled, scroll the document\n    if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {\n      moveScroll(document.documentElement, dir);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)\n   * depending on the directional information.\n   * @function spatNavCandidates\n   * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information\n   * @param container {Node} - The spatial navigation container\n   * @returns {Node} The candidates for spatial navigation considering the directional information\n   */\n  function spatNavCandidates (element, dir, candidates, container) {\n    let targetElement = element;\n    // If the container is unknown, get the closest container from the element\n    container = container || targetElement.getSpatialNavigationContainer();\n\n    // If the candidates is unknown, find candidates\n    // 5-1\n    if (!candidates || candidates.length <= 0) {\n      if ((isContainer(targetElement) || targetElement.nodeName === 'BODY') && !(targetElement.nodeName === 'INPUT')) {\n        if (targetElement.nodeName === 'IFRAME')\n          targetElement = targetElement.contentDocument.body;\n\n        candidates = targetElement.focusableAreas();\n      }\n      else {\n        candidates = filteredCandidates(targetElement, container.focusableAreas(), dir, container);\n      }\n    }\n    else {\n      candidates = filteredCandidates(targetElement, candidates, dir, container);\n    }\n    return candidates;\n  }\n\n  /**\n   * Find the best candidate among the candidates within the container from the search origin (currently focused element)\n   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}\n   * @function spatialNavigationSearch\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @param candidates {sequence<Node>} - The candidates for spatial navigation\n   * @param container {Node} - The spatial navigation container\n   * @returns {Node} The best candidate which will gain the focus\n   */\n  function spatialNavigationSearch (dir, candidates, container) {\n    // Let container be the nearest ancestor of eventTarget that is a spatnav container.\n\n    // targetElement === eventTarget\n    const targetElement = this;\n    candidates = spatNavCandidates(targetElement, dir, candidates, container);\n\n    // Find the best candidate\n    // 5\n    // If startingPoint is either a scroll container or the document,\n    // find the best candidate within startingPoint\n    if (candidates && candidates.length > 0) {\n      if ((isContainer(targetElement) || targetElement.nodeName === 'BODY') && !(targetElement.nodeName === 'INPUT')) {\n        const targetElementInTarget = targetElement.focusableAreas();\n        if (candidates.every(x => targetElementInTarget.includes(x))) {\n          // if candidates are contained in the targetElement, then the focus moves inside the targetElement\n          return selectBestCandidateFromEdge(targetElement, candidates, dir);\n        }\n      }\n      return selectBestCandidate(targetElement, candidates, dir);\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the filtered candidate among candidates.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n   * @function filteredCandidates\n   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n   * @param candidates {sequence<Node>} - The candidates for spatial navigation\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @param container {Node} - The spatial navigation container\n   * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin\n   */\n  function filteredCandidates(currentElm, candidates, dir, container) {\n    const originalContainer = currentElm.getSpatialNavigationContainer();\n    let eventTargetRect;\n\n    // If D(dir) is null, let candidates be the same as visibles\n    if (dir === undefined)\n      return candidates;\n\n    // to do\n    // Offscreen handling when originalContainer is not <HTML>\n    if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm))\n      eventTargetRect = getBoundingClientRect(originalContainer);\n    else eventTargetRect = getBoundingClientRect(currentElm);\n\n    /*\n     * Else, let candidates be the subset of the elements in visibles\n     * whose principal boxâ€™s geometric center is within the closed half plane\n     * whose boundary goes through the geometric center of starting point and is perpendicular to D.\n     */\n    return candidates.filter(candidate =>\n      container.contains(candidate) &&\n      isOutside(getBoundingClientRect(candidate), eventTargetRect, dir)\n    );\n  }\n\n  /**\n   * Select the best candidate among given candidates.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}\n   * @function selectBestCandidate\n   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n   * @param candidates {sequence<Node>} - The candidates for spatial navigation\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {Node} The best candidate which will gain the focus\n   */\n  function selectBestCandidate(currentElm, candidates, dir) {\n    return getClosestElement(currentElm, candidates, dir, getDistance);\n  }\n\n  /**\n   * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).\n   * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}\n   * @function selectBestCandidateFromEdge\n   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n   * @param candidates {sequence<Node>} - The candidates for spatial navigation\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {Node} The best candidate which will gain the focus\n   */\n  function selectBestCandidateFromEdge(currentElm, candidates, dir) {\n    if (startingPoint)\n      return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);\n    else\n      return getClosestElement(currentElm, candidates, dir, getInnerDistance);    \n  }\n\n\n  /**\n   * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.\n   * @function getClosestElement\n   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec\n   * @param candidates {sequence<Node>} - The candidates for spatial navigation\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate\n   * @returns {Node} The candidate which is the closest one from the search origin\n   */\n  function getClosestElement(currentElm, candidates, dir, distanceFunction) {\n    const eventTargetRect = getBoundingClientRect(currentElm);\n    let minDistance = Number.POSITIVE_INFINITY;\n    let minDistanceElement = undefined;\n\n    if (candidates) {\n      for (let i = 0; i < candidates.length; i++) {\n        const distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir);\n\n        // If the same distance, the candidate will be selected in the DOM order\n        if (distance < minDistance) {\n          minDistance = distance;\n          minDistanceElement = candidates[i];\n        }\n      }\n    }\n\n    return minDistanceElement;\n  }\n\n  /**\n   * Get container of an element.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}\n   * @module Element\n   * @function getSpatialNavigationContainer\n   * @returns {Node} The spatial navigation container\n   */\n  function getSpatialNavigationContainer() {\n    let container = this;\n\n    while(!isContainer(container)) {\n      if (!container.parentElement) {\n        if (window.location !== window.parent.location)\n          container = window.parent.document.documentElement;\n        else\n          container = window.document.documentElement;\n        break;\n      }\n      else {\n        container = container.parentElement;\n      }\n    }\n    return container;\n  }\n\n  /**\n   * Find focusable elements within the spatial navigation container.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}\n   * @function focusableAreas\n   * @param option {FocusableAreasOptions} - 'mode' attribute takes visible' or 'all' for searching the boundary of focosable elements.\n   *                                          Default value is 'visible'.\n   * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container\n   */\n  function focusableAreas(option = {mode: 'visible'}) {\n    const container = this.parentElement ? this : document.body;\n    const focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);\n    return (option.mode === 'all') ? focusables : focusables.filter(isVisible);\n  }\n\n  /**\n   * Create the NavigatoinEvent: navbeforefocus, navnotarget\n   * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}\n   * @function createSpatNavEvents\n   * @param option {string} - Type of the navigation event (beforefocus, notarget)\n   * @param element {Node} - The target element of the event\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   */\n  function createSpatNavEvents(eventType, containerElement, currentElement, direction) {\n    const data = {\n      causedTarget: currentElement,\n      dir: direction\n    };\n\n    let triggeredEvent = null;\n\n    switch (eventType) {\n    case 'beforefocus':\n      triggeredEvent = new CustomEvent('navbeforefocus', {bubbles: true, cancelable: true, detail: data});\n      break;\n\n    case 'notarget':\n      triggeredEvent = new CustomEvent('navnotarget', {bubbles: true, cancelable: true, detail: data});\n      break;\n    }\n\n    if (triggeredEvent !== null) {\n      containerElement.dispatchEvent(triggeredEvent);\n    }\n  }\n\n  /**\n   * Get the value of the CSS custom property of the element\n   * @function readCssVar\n   * @param element {Node}\n   * @param varName {string} - The name of the css custom property without '--'\n   * @returns {string} The value of the css custom property\n   */\n  function readCssVar(element, varName) {\n    return element.style.getPropertyValue(`--${varName}`).trim();\n  }\n\n  /**\n   * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element\n   * @function isCSSSpatNavContain\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isCSSSpatNavContain(element) {\n    return readCssVar(element, 'spatial-navigation-contain') === 'contain';\n  }\n\n  /**\n   * Return the value of 'spatial-navigation-action' css property of an element\n   * @function getCSSSpatNavAction\n   * @param element {Node} - would be the spatial navigation container\n   * @returns {string} auto | focus | scroll\n   */\n  function getCSSSpatNavAction(element) {\n    if (readCssVar(element, 'spatial-navigation-action') === '')\n      return 'auto';\n    return readCssVar(element, 'spatial-navigation-action');\n  }\n\n  /**\n   * Only move the focus with spatial navigation. Manually scrolling isn't available.\n   * @function navigateChain\n   * @param eventTarget {Node} - currently focused element\n   * @param container {SpatialNavigationContainer} - container\n   * @param parentContainer {SpatialNavigationContainer} - parent container\n   * @param option - visiable || all\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   */\n  function navigateChain(eventTarget, container, option, dir) {\n    \n    let parentContainer = (container.parentElement) ? container.parentElement.getSpatialNavigationContainer() : null;\n    // When the container is the viewport of a browsing context\n    if (!parentContainer && ( window.location !== window.parent.location)) {\n      parentContainer = window.parent.document.documentElement;\n    }\n\n    // spatial navigation step\n    // 7\n    while (parentContainer) {\n      if (focusingController(eventTarget.spatialNavigationSearch(dir, container.focusableAreas({mode: option}), container), dir)) {\n        return;\n      }\n      else {\n        // If there isn't any candidate and the best candidate among candidate: Find candidates of the ancestor container\n\n        // [event] navnotarget : Fired when spatial navigation has failed to find any acceptable candidate to move the focus\n        // to in the current spatnav container and when that same spatnav container cannot be scrolled either,\n        // before going up the tree to search in the nearest ancestor spatnav container.\n\n        if ((option === 'visible') && scrollingController(container, dir)) return;\n\n        createSpatNavEvents('notarget', container, eventTarget, dir);\n        if (navnotargetPrevented) break;\n\n        // find the container\n        if (container === document || container === document.documentElement) {\n          if ( window.location !== window.parent.location ) {\n            // The page is in an iframe\n            // eventTarget needs to be reset because the position of the element in the IFRAME\n            // is unuseful when the focus moves out of the iframe\n            eventTarget = window.frameElement;\n            container = window.parent.document.documentElement;\n          }\n        }\n        else {\n          // avoiding when spatnav container with tabindex=-1\n          if (isFocusable(container) && (eventTarget !== container))\n            eventTarget = container;\n\n          container = parentContainer;\n        }\n\n        parentContainer = (container.parentElement) ? container.parentElement.getSpatialNavigationContainer() : null;\n      }\n    }\n\n    // Behavior after 'navnotarget' - Getting out of the current spatnav container\n    if (!parentContainer && container) {\n      if (focusingController(eventTarget.spatialNavigationSearch(dir, container.focusableAreas(), container), dir))\n        return;\n    }\n  }\n\n  /**\n   * Find search origin\n   * @see {@link https://drafts.csswg.org/css-nav-1/#nav}\n   * @function findSearchOrigin\n   * @returns {Node} The search origin for the spatial navigation\n   */\n  function findSearchOrigin() {\n    let searchOrigin = document.activeElement;\n    if (!searchOrigin ||\n      (searchOrigin === document.body && !document.querySelector(':focus')) /* body isn't actually focused*/\n    ) {\n      searchOrigin = document;\n    }\n    return searchOrigin;\n  }\n\n  /**\n   * Move the scroll of an element depending on the given spatial navigation directrion\n   * (Assume that User Agent defined distance is '40px')\n   * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}\n   * @function moveScroll\n   * @param element {Node} - The scrollable element\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.\n   */\n  function moveScroll(element, dir, offset = 0) {\n    if (element) {\n      switch (dir) {\n      case 'left': element.scrollLeft -= (40 + offset); break;\n      case 'right': element.scrollLeft += (40 + offset); break;\n      case 'up': element.scrollTop -= (40 + offset); break;\n      case 'down': element.scrollTop += (40 + offset); break;\n      }\n    }\n  }\n\n  /**\n   * Decide whether an element is container or not.\n   * @function isContainer\n   * @param element {Node} element\n   * @returns {boolean}\n   */\n  function isContainer(element) {\n    return (!element.parentElement) ||\n            (element.nodeName === 'IFRAME') ||\n            (isScrollContainer(element)) ||\n            (isCSSSpatNavContain(element));\n  }\n\n  /**\n   * Decide whether an element is a scrollable container or not.\n   * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}\n   * @function isScrollContainer\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isScrollContainer(element) {\n    const elementStyle = window.getComputedStyle(element, null);\n    const overflowX = elementStyle.getPropertyValue('overflow-x');\n    const overflowY = elementStyle.getPropertyValue('overflow-y');\n    return (overflowX !== 'visible' && overflowX !== 'clip') && (overflowY !== 'visible' && overflowY !== 'clip');\n  }\n\n  /**\n   * Decide whether this element is scrollable or not.\n   * @function isScrollable\n   * @param element {Node}\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function isScrollable(element, dir) { // element, dir\n    if (element && typeof element === 'object') {\n      if (dir && typeof dir === 'string') { // parameter: dir, element\n        if (isOverflow(element, dir)) {\n          // style property\n          const elementStyle = window.getComputedStyle(element, null);\n          const overflowX = elementStyle.getPropertyValue('overflow-x');\n          const overflowY = elementStyle.getPropertyValue('overflow-y');\n\n          switch (dir) {\n          case 'left':\n            /* falls through */\n          case 'right':\n            return (overflowX !== 'visible' && overflowX !== 'clip');\n          case 'up':\n            /* falls through */\n          case 'down':\n            return (overflowY !== 'visible' && overflowY !== 'clip');\n          }\n        }\n        return false;\n      } else { // parameter: element\n        return (element.nodeName === 'HTML' || element.nodeName === 'BODY') ||\n                (isScrollContainer(element) && isOverflow(element));\n      }\n    }\n  }\n\n  /**\n   * Decide whether an element is overflow or not.\n   * @function isOverflow\n   * @param element {Node}\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function isOverflow(element, dir) {\n    if (element && typeof element === 'object') {\n      if (dir && typeof dir === 'string') { // parameter: element, dir\n        switch (dir) {\n        case 'left':\n          /* falls through */\n        case 'right':\n          return (element.scrollWidth > element.clientWidth);\n        case 'up':\n          /* falls through */\n        case 'down':\n          return (element.scrollHeight > element.clientHeight);\n        }\n      } else { // parameter: element\n        return (element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Decide whether the scrollbar of the browsing context reaches to the end or not.\n   * @function isHTMLScrollBoundary\n   * @param element {Node} - The top browsing context\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function isHTMLScrollBoundary(element, dir) {\n    let result = false;\n    switch (dir) {\n    case 'left':\n      result = window.scrollX === 0;\n      break;\n    case 'right':\n      result = (element.scrollWidth - element.scrollLeft - element.clientWidth) === 0;\n      break;\n    case 'up':\n      result = window.scrollY === 0;\n      break;\n    case 'down':\n      result = (element.scrollHeight - element.scrollTop - element.clientHeight) === 0;\n      break;\n    }\n    return result;\n  }\n\n  /**\n   * Decide whether the scrollbar of an element reaches to the end or not.\n   * @function isScrollBoundary\n   * @param element {Node}\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function isScrollBoundary(element, dir) {\n    if (isScrollable(element, dir)) {\n      const winScrollY = element.scrollTop;\n      const winScrollX = element.scrollLeft;\n\n      const height = element.scrollHeight - element.clientHeight;\n      const width = element.scrollWidth - element.clientWidth;\n\n      switch (dir) {\n      case 'left': return (winScrollX === 0);\n      case 'right': return (Math.abs(winScrollX - width) <= 1);\n      case 'up': return (winScrollY === 0);\n      case 'down': return (Math.abs(winScrollY - height) <= 1);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Decide whether an element is focusable for spatial navigation.\n   * 1. If element is the browsing context (document, iframe), then it's focusable,\n   * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,\n   * 3. The value of tabIndex >= 0, then it's focusable,\n   * 4. If the element is disabled, it isn't focusable,\n   * 5. If the element is expressly inert, it isn't focusable,\n   * 6. Whether the element is being rendered or not.\n   *\n   * @function isFocusable\n   * @param element {Node}\n   * @returns {boolean}\n   *\n   * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}\n   */\n  function isFocusable(element) {\n    if ((element.tabIndex < 0) || isAtagWithoutHref(element) || isActuallyDisabled(element) || isExpresslyInert(element) || !isBeingRendered(element))\n      return false;\n    else if ((!element.parentElement) || (isScrollable(element) && isOverflow(element)) || (element.tabIndex >= 0))\n      return true;\n  }\n\n  /**\n   * Decide whether an element is a tag without href attribute or not.\n   *\n   * @function isAtagWithoutHref\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isAtagWithoutHref(element) {\n    return (element.tagName === 'A' && element.getAttribute('href') === null && element.getAttribute('tabIndex') === null);\n  }\n\n  /**\n   * Decide whether an element is actually disabled or not.\n   *\n   * @function isActuallyDisabled\n   * @param element {Node}\n   * @returns {boolean}\n   *\n   * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}\n   */\n  function isActuallyDisabled(element) {\n    if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName))\n      return (element.disabled);\n    else\n      return false;\n  }\n\n  /**\n   * Decide whether the element is expressly inert or not.\n   * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}\n   * @function isExpresslyInert\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isExpresslyInert(element) {\n    return ((element.inert) && (!element.ownerDocument.documentElement.inert));\n  }\n\n  /**\n   * Decide whether the element is being rendered or not.\n   * 1. If an element has the style as \"visibility: hidden | collapse\" or \"display: none\", it is not being rendered.\n   * 2. If an element has the style as \"opacity: 0\", it is not being rendered.(that is, invisible).\n   * 3. If width and height of an element are explicitly set to 0, it is not being rendered.\n   * 4. If a parent element is hidden, an element itself is not being rendered.\n   * (CSS visibility property and display property are inherited.)\n   * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}\n   * @function isBeingRendered\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isBeingRendered(element) {\n    if (!isVisibleStyleProperty(element.parentElement))\n      return false;\n    if (!isVisibleStyleProperty(element) || (element.style.opacity === 0) ||\n        ((element.style.width === '0px' || element.style.width === 0) && (element.style.height === '0px' || element.style.height === 0)))\n      return false;    \n    return true;\n  }\n\n  /**\n   * Decide whether this element is partially or completely visible to user agent.\n   * @function isVisible\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isVisible(element) {\n    return (!element.parentElement) || (isVisibleStyleProperty(element) && hitTest(element));\n  }\n\n  /**\n   * Decide whether this element is completely visible in this viewport for the arrow direction.\n   * @function isEntirelyVisible\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function isEntirelyVisible(element) {\n    const rect = getBoundingClientRect(element);\n    const containerRect = getBoundingClientRect(element.getSpatialNavigationContainer());\n\n    // FIXME: when element is bigger than container?\n    const entirelyVisible = !((rect.left < containerRect.left) ||\n      (rect.right > containerRect.right) ||\n      (rect.top < containerRect.top) ||\n      (rect.bottom > containerRect.bottom));\n\n    return entirelyVisible;\n  }\n\n  /**\n   * Decide the style property of this element is specified whether it's visible or not.\n   * @function isVisibleStyleProperty\n   * @param element {CSSStyleDeclaration}\n   * @returns {boolean}\n   */\n  function isVisibleStyleProperty(element) {\n    const elementStyle = window.getComputedStyle(element, null);\n    const thisVisibility = elementStyle.getPropertyValue('visibility');\n    const thisDisplay = elementStyle.getPropertyValue('display');\n    const invisibleStyle = ['hidden', 'collapse'];\n\n    return (thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility));\n  }\n\n  /**\n   * Decide whether this element is entirely or partially visible within the viewport.\n   * @function hitTest\n   * @param element {Node}\n   * @returns {boolean}\n   */\n  function hitTest(element) {\n    let offsetX = parseInt(element.offsetWidth) / 10;\n    let offsetY = parseInt(element.offsetHeight) / 10;\n\n    offsetX = isNaN(offsetX) ? 1 : offsetX;\n    offsetY = isNaN(offsetY) ? 1 : offsetY;\n\n    const elementRect = getBoundingClientRect(element);\n\n    const middleElem = document.elementFromPoint((elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2);\n    if (element === middleElem || element.contains(middleElem)) {\n      return true;\n    }\n\n    const leftTopElem = document.elementFromPoint(elementRect.left + offsetX, elementRect.top + offsetY);\n    if (element === leftTopElem || element.contains(leftTopElem)) {\n      return true;\n    }\n\n    const leftBottomElem = document.elementFromPoint(elementRect.left + offsetX, elementRect.bottom - offsetY);\n    if (element === leftBottomElem || element.contains(leftBottomElem)) {\n      return true;\n    }\n\n    const rightTopElem = document.elementFromPoint(elementRect.right - offsetX, elementRect.top + offsetY);\n    if (element === rightTopElem || element.contains(rightTopElem)) {\n      return true;\n    }\n\n    const rightBottomElem = document.elementFromPoint(elementRect.right - offsetX, elementRect.bottom - offsetY);\n    if (element === rightBottomElem || element.contains(rightBottomElem)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Decide whether this element is entirely or partially visible within the viewport.\n   * Note: rect1 is outside of rect2 for the dir\n   * @function isOutside\n   * @param rect1 {DOMRect}\n   * @param rect2 {DOMRect}\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {boolean}\n   */\n  function isOutside(rect1, rect2, dir) {\n    switch (dir) {\n    case 'left':\n      return isRightSide(rect2, rect1);\n    case 'right':\n      return isRightSide(rect1, rect2);\n    case 'up':\n      return isBelow(rect2, rect1);\n    case 'down':\n      return isBelow(rect1, rect2);\n    default:\n      return false;\n    }\n  }\n\n  /* rect1 is right of rect2 */\n  function isRightSide(rect1, rect2) {\n    return rect1.left >= rect2.right || (rect1.left >= rect2.left && rect1.right > rect2.right && rect1.bottom > rect2.top && rect1.top < rect2.bottom);\n  }\n\n  /* rect1 is below of rect2 */\n  function isBelow(rect1, rect2) {\n    return rect1.top >= rect2.bottom || (rect1.top >= rect2.top && rect1.bottom > rect2.bottom && rect1.left < rect2.right && rect1.right > rect2.left);\n  }\n\n  /* rect1 is completely aligned or partially aligned for the direction */\n  function isAligned(rect1, rect2, dir) {\n    switch (dir) {\n    case 'left' :\n      /* falls through */\n    case 'right' :\n      return rect1.bottom > rect2.top && rect1.top < rect2.bottom;\n    case 'up' :\n      /* falls through */\n    case 'down' :\n      return rect1.right > rect2.left && rect1.left < rect2.right;\n    default:\n      return false;\n    }\n  }\n\n  /**\n   * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n   * @function getDistanceFromPoint\n   * @param point {Point} - The search origin\n   * @param element {DOMRect} - A candidate element\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it\n   */\n  function getDistanceFromPoint(point, element, dir) {\n    point = startingPoint;\n    // Get exit point, entry point -> {x: '', y: ''};\n    const points = getEntryAndExitPoints(dir, point, element);\n\n    // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n    // that minimize the distance between these two points\n    const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n    const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n    // The result is euclidian distance between P1 and P2.\n    return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n  }\n\n  /**\n   * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n   * @function getInnerDistance\n   * @param rect1 {DOMRect} - The search origin\n   * @param rect2 {DOMRect} - A candidate element\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it\n   */\n  function getInnerDistance(rect1, rect2, dir) {\n    const baseEdgeForEachDirection = {left: 'right', right: 'left', up: 'bottom', down: 'top'};\n    const baseEdge = baseEdgeForEachDirection[dir];\n\n    return Math.abs(rect1[baseEdge] - rect2[baseEdge]);\n  }\n\n  /**\n   * Get the distance between the search origin and a candidate element considering the direction.\n   * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}\n   * @function getDistance\n   * @param searchOrigin {DOMRect || Point} - The search origin\n   * @param element2 {DOMRect} - A candidate element\n   * @param candidateRect {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)\n   * @returns {Number} The distance scoring between two elements\n   */\n  function getDistance(searchOrigin, candidateRect, dir) {\n    const kOrthogonalWeightForLeftRight = 30;\n    const kOrthogonalWeightForUpDown = 2;\n\n    let orthogonalBias = 0;\n    let alignBias = 0;\n    const alignWeight = 5.0;\n\n    // Get exit point, entry point -> {x: '', y: ''};\n    const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);\n\n    // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate\n    // that minimize the distance between these two points\n    const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);\n    const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);\n\n    // A: The euclidian distance between P1 and P2.\n    const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));\n    let B, C;\n\n    // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.\n    // C: The intersection edges between a candidate and the starting point.\n\n    // D: The square root of the area of intersection between the border boxes of candidate and starting point\n    const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);\n    const D = intersectionRect.area;\n\n    switch (dir) {\n    case 'left':\n      /* falls through */\n    case 'right' :\n      // If two elements are aligned, add align bias\n      // else, add orthogonal bias\n      if (isAligned(searchOrigin, candidateRect, dir))\n        alignBias = Math.min(intersectionRect.height / searchOrigin.height , 1);\n      else\n        orthogonalBias = (searchOrigin.height / 2);\n\n      B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;\n      C = alignWeight * alignBias;\n      break;\n\n    case 'up' :\n      /* falls through */\n    case 'down' :\n      // If two elements are aligned, add align bias\n      // else, add orthogonal bias\n      if (isAligned(searchOrigin, candidateRect, dir))\n        alignBias = Math.min(intersectionRect.width / searchOrigin.width , 1);\n      else\n        orthogonalBias = (searchOrigin.width / 2);\n\n      B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;\n      C = alignWeight * alignBias;\n      break;\n\n    default:\n      B = 0;\n      C = 0;\n      break;\n    }\n\n    return (A + B - C - D);\n  }\n\n  /**\n   * Get entry point and exit point of two elements considering the direction.\n   * @function getEntryAndExitPoints\n   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.\n   * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point\n   * @param candidateRect {DOMRect} - One of candidates which contains the entry point\n   * @returns {Points} The exit point from the search origin and the entry point from a candidate\n   */\n  function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {\n    /**\n     * User type definition for Point\n     * @typeof {Object} Points\n     * @property {Point} Points.entryPoint\n     * @property {Point} Points.exitPoint\n     */\n    const points = {entryPoint: {x: 0, y: 0}, exitPoint:{x: 0, y: 0}};\n\n    if (startingPoint) {\n      points.exitPoint = searchOrigin;\n\n      switch (dir) {\n      case 'left':\n        points.entryPoint.x = candidateRect.right;\n        break;\n      case 'up':\n        points.entryPoint.y = candidateRect.bottom;\n        break;\n      case 'right':\n        points.entryPoint.x = candidateRect.left;\n        break;\n      case 'down':\n        points.entryPoint.y = candidateRect.top;\n        break;\n      }\n  \n      // Set orthogonal direction\n      switch (dir) {\n      case 'left':\n      case 'right':\n        if (startingPoint.y <= candidateRect.top) {\n          points.entryPoint.y = candidateRect.top;\n        } else if (startingPoint.y < candidateRect.bottom) {\n          points.entryPoint.y = startingPoint.y;\n        } else {\n          points.entryPoint.y = candidateRect.bottom;\n        }\n        break;\n  \n      case 'up':\n      case 'down':\n        if (startingPoint.x <= candidateRect.left) {\n          points.entryPoint.x = candidateRect.left;\n        } else if (startingPoint.x < candidateRect.right) {\n          points.entryPoint.x = startingPoint.x;\n        } else {\n          points.entryPoint.x = candidateRect.right;\n        }\n        break;\n      }\n    }\n    else {\n      // Set direction\n      switch (dir) {\n      case 'left':\n        points.exitPoint.x = searchOrigin.left;\n        points.entryPoint.x = (candidateRect.right < searchOrigin.left) ? candidateRect.right : searchOrigin.left;\n        break;\n      case 'up':\n        points.exitPoint.y = searchOrigin.top;\n        points.entryPoint.y = (candidateRect.bottom < searchOrigin.top) ? candidateRect.bottom : searchOrigin.top;\n        break;\n      case 'right':\n        points.exitPoint.x = searchOrigin.right;\n        points.entryPoint.x = (candidateRect.left > searchOrigin.right) ? candidateRect.left : searchOrigin.right;\n        break;\n      case 'down':\n        points.exitPoint.y = searchOrigin.bottom;\n        points.entryPoint.y = (candidateRect.top > searchOrigin.bottom) ? candidateRect.top : searchOrigin.bottom;\n        break;\n      }\n  \n      // Set orthogonal direction\n      switch (dir) {\n      case 'left':\n      case 'right':\n        if (isBelow(searchOrigin, candidateRect)) {\n          points.exitPoint.y = searchOrigin.top;\n          points.entryPoint.y = (candidateRect.bottom < searchOrigin.top) ? candidateRect.bottom : searchOrigin.top;\n        } else if (isBelow(candidateRect, searchOrigin)) {\n          points.exitPoint.y = searchOrigin.bottom;\n          points.entryPoint.y = (candidateRect.top > searchOrigin.bottom) ? candidateRect.top : searchOrigin.bottom;\n        } else {\n          points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);\n          points.entryPoint.y = points.exitPoint.y;\n        }\n        break;\n  \n      case 'up':\n      case 'down':\n        if (isRightSide(searchOrigin, candidateRect)) {\n          points.exitPoint.x = searchOrigin.left;\n          points.entryPoint.x = (candidateRect.right < searchOrigin.left) ? candidateRect.right : searchOrigin.left;\n        } else if (isRightSide(candidateRect, searchOrigin)) {\n          points.exitPoint.x = searchOrigin.right;\n          points.entryPoint.x = (candidateRect.left > searchOrigin.right) ? candidateRect.left : searchOrigin.right;\n        } else {\n          points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);\n          points.entryPoint.x = points.exitPoint.x;\n        }\n        break;\n      }\n    } \n    \n    return points;\n  }\n\n  /**\n   * Find focusable elements within the container\n   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}\n   * @function getIntersectionRect\n   * @param rect1 {DOMRect} - The search origin which contains the exit point\n   * @param rect2 {DOMRect} - One of candidates which contains the entry point\n   * @returns {IntersectionArea} The intersection area between two elements.\n   *\n   * @typeof {Object} IntersectionArea\n   * @property {Number} IntersectionArea.width\n   * @property {Number} IntersectionArea.height\n   */\n  function getIntersectionRect(rect1, rect2) {\n    const intersection_rect = {width: 0, height: 0, area: 0};\n\n    const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];\n    const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];\n\n    intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);\n    intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);\n\n    if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {\n      // intersecting-cases\n      intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);\n    }\n    \n    return intersection_rect;\n  }\n\n  /**\n   * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}\n   * @function handlingEditableElement\n   * @param e {Event} - keydownEvent\n   * @returns {boolean}\n   */\n  function handlingEditableElement(e) {\n    const SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],\n      TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];\n    const eventTarget = document.activeElement;\n    const startPosition = eventTarget.selectionStart;\n    const endPosition = eventTarget.selectionEnd;\n    const focusNavigableArrowKey = {left: false, up: false, right: false, down: false};\n\n    const dir = ARROW_KEY_CODE[e.keyCode];\n    if (dir === undefined) {\n      return focusNavigableArrowKey;\n    }\n\n    if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) &&\n      (dir === 'up' || dir === 'down')) {\n      focusNavigableArrowKey[dir] = true;\n    }\n    else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA') {\n      if (startPosition === endPosition) { // if there isn't any selected text\n        if (startPosition === 0) {\n          focusNavigableArrowKey.left = true;\n          focusNavigableArrowKey.up = true;\n        }\n        if (endPosition === eventTarget.value.length) {\n          focusNavigableArrowKey.right = true;\n          focusNavigableArrowKey.down = true;\n        }\n      }\n    }\n    else { // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup\n      focusNavigableArrowKey[dir] = true;\n    }\n\n    return focusNavigableArrowKey;\n  }\n\n  /**\n   * Get the DOMRect of an element\n   * @function getBoundingClientRect\n   * @param element {Node}\n   * @returns {DOMRect}\n   */\n  function getBoundingClientRect(element) {\n    // memoization\n    let rect = mapOfBoundRect && mapOfBoundRect.get(element);\n    if (!rect) {\n      const boundingClientRect = element.getBoundingClientRect();\n      rect = {\n        top: Number(boundingClientRect.top.toFixed(2)),\n        right: Number(boundingClientRect.right.toFixed(2)),\n        bottom: Number(boundingClientRect.bottom.toFixed(2)),\n        left: Number(boundingClientRect.left.toFixed(2)),\n        width: Number(boundingClientRect.width.toFixed(2)),\n        height: Number(boundingClientRect.height.toFixed(2))\n      };\n      mapOfBoundRect && mapOfBoundRect.set(element, rect);\n    }\n    return rect;\n  }\n\n  /**\n   * Get the list of the experimental APIs\n   * @function getExperimentalAPI\n   */\n  function getExperimentalAPI() {\n    function canScroll(container, dir) {\n      return (isScrollable(container, dir) && !isScrollBoundary(container, dir)) ||\n             (!container.parentElement && !isHTMLScrollBoundary(container, dir));\n    }\n\n\n    function findTarget(findCandidate, element, dir, option) {\n      let eventTarget = element;\n      let bestNextTarget = null;\n\n      // 4\n      if (eventTarget === document || eventTarget === document.documentElement) {\n        eventTarget = document.body || document.documentElement;\n      }\n\n      // 5\n      // At this point, spatialNavigationSearch can be applied.\n      // If startingPoint is either a scroll container or the document,\n      // find the best candidate within startingPoint\n      if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {\n        if (eventTarget.nodeName === 'IFRAME')\n          eventTarget = eventTarget.contentDocument.body;\n\n        const candidates = eventTarget.focusableAreas(option);\n\n        // 5-2\n        if (Array.isArray(candidates) && candidates.length > 0) {\n          return findCandidate ? spatNavCandidates(eventTarget, dir, candidates) : eventTarget.spatialNavigationSearch(dir, candidates);\n        }\n        if (canScroll(eventTarget, dir)) {\n          return findCandidate ? [] : eventTarget;\n        }\n      }\n\n      // 6\n      // Let container be the nearest ancestor of eventTarget\n      let container = eventTarget.getSpatialNavigationContainer();\n      let parentContainer = (container.parentElement) ? container.parentElement.getSpatialNavigationContainer() : null;\n\n      // When the container is the viewport of a browsing context\n      if (!parentContainer && ( window.location !== window.parent.location)) {\n        parentContainer = window.parent.document.documentElement;\n      }\n\n      // 7\n      while (parentContainer) {\n        const candidates = filteredCandidates(eventTarget, container.focusableAreas(option), dir, container);\n\n        if (Array.isArray(candidates) && candidates.length > 0) {\n          bestNextTarget = eventTarget.spatialNavigationSearch(dir, candidates, container);\n          if (bestNextTarget) {\n            return findCandidate ? candidates : bestNextTarget;\n          }\n        }\n\n        // If there isn't any candidate and the best candidate among candidate:\n        // 1) Scroll or 2) Find candidates of the ancestor container\n        // 8 - if\n        else if (canScroll(container, dir)) {\n          return findCandidate ? [] : eventTarget;\n        } else if (container === document || container === document.documentElement) {\n          container = window.document.documentElement;\n\n          // The page is in an iframe\n          if ( window.location !== window.parent.location ) {\n\n            // eventTarget needs to be reset because the position of the element in the IFRAME\n            // is unuseful when the focus moves out of the iframe\n            eventTarget = window.frameElement;\n            container = window.parent.document.documentElement;\n            if (container.parentElement)\n              parentContainer = container.parentElement.getSpatialNavigationContainer();\n            else {\n              parentContainer = null;\n              break;\n            }\n          }\n        } else {\n          // avoiding when spatnav container with tabindex=-1\n          if (isFocusable(container)) {\n            eventTarget = container;\n          }\n\n          container = parentContainer;\n          if (container.parentElement)\n            parentContainer = container.parentElement.getSpatialNavigationContainer();\n          else {\n            parentContainer = null;\n            break;\n          }\n        }\n      }\n\n      if (!parentContainer && container) {\n        // Getting out from the current spatnav container\n        const candidates = filteredCandidates(eventTarget, container.focusableAreas(option), dir, container);\n\n        // 9\n        if (Array.isArray(candidates) && candidates.length > 0) {\n          bestNextTarget = eventTarget.spatialNavigationSearch(dir, candidates, container);\n          if (bestNextTarget) {\n            return findCandidate ? candidates : bestNextTarget;\n          }\n        }\n      }\n\n      if (canScroll(container, dir)) {\n        bestNextTarget = eventTarget;\n        return bestNextTarget;\n      }\n    }\n\n    return {\n      isContainer,\n      findCandidates: findTarget.bind(null, true),\n      findNextTarget: findTarget.bind(null, false),\n      getDistanceFromTarget: (element, candidateElement, dir) => {\n        if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {\n          if (element.focusableAreas().includes(candidateElement)) {\n            return getInnerDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);\n          }\n        }\n        return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);\n      }\n    };\n  }\n\n  /**\n   * Makes to use the experimental APIs.\n   * @function enableExperimentalAPIs\n   * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.\n   */\n  function enableExperimentalAPIs (option) {\n    const currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;\n    window.__spatialNavigation__ = (option === false) ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());\n    window.__spatialNavigation__.keyMode = currentKeyMode;\n    Object.seal(window.__spatialNavigation__);\n  }\n\n  /**\n   * Set the environment for using the spatial navigation polyfill.\n   * @function getInitialAPIs\n   */\n  function getInitialAPIs() {\n    return {\n      enableExperimentalAPIs,\n      get keyMode() { return this._keymode ? this._keymode : 'ARROW'; },\n      set keyMode(mode) { this._keymode = (['SHIFTARROW', 'ARROW', 'NONE'].includes(mode)) ? mode : 'ARROW'; },\n    };\n  }\n\n  window.addEventListener('load', () => {\n    initiateSpatialNavigation();\n    enableExperimentalAPIs(false);\n  });\n})();\n"]}